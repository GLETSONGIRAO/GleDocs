{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Glet Docs Um projeto para documentar o aprendizado e os principais processos em Data Science.","title":"Glet Docs"},{"location":"#glet-docs","text":"Um projeto para documentar o aprendizado e os principais processos em Data Science.","title":"Glet Docs"},{"location":"Conda/","text":"Criando um enviroment Envs s\u00e3o instalados no diret\u00f3rio envs dentro do diret\u00f3rio do conda Criar um env com conda: conda create --name myenv Apertar y quando conda perguntar \"proceed ([y]/n)?\" Isso cria um env sem nenhum pacote instalado. Env com vers\u00e3o espec\u00edfica de Python: conda create -n myenv python=3.9 Utilidades Ativando um enviroment conda activate myenv Informa\u00e7\u00f5es Mostar todos os ambientes criados. O que tem um asterisco * \u00e9 o atual. conda info --envs # ou conda env list Mostrar todos os pacotes de um env: conda list Usar pip em um env conda install -n myenv pip conda activate myenv pip <pip_subcommand> Clonando um enviroment conda create --name myclone --clone myenv Remover um Env conda remove --name myenv --all","title":"Criando um enviroment"},{"location":"Conda/#criando-um-enviroment","text":"Envs s\u00e3o instalados no diret\u00f3rio envs dentro do diret\u00f3rio do conda Criar um env com conda: conda create --name myenv Apertar y quando conda perguntar \"proceed ([y]/n)?\" Isso cria um env sem nenhum pacote instalado. Env com vers\u00e3o espec\u00edfica de Python: conda create -n myenv python=3.9","title":"Criando um enviroment"},{"location":"Conda/#utilidades","text":"","title":"Utilidades"},{"location":"Conda/#ativando-um-enviroment","text":"conda activate myenv","title":"Ativando um enviroment"},{"location":"Conda/#informacoes","text":"Mostar todos os ambientes criados. O que tem um asterisco * \u00e9 o atual. conda info --envs # ou conda env list Mostrar todos os pacotes de um env: conda list","title":"Informa\u00e7\u00f5es"},{"location":"Conda/#usar-pip-em-um-env","text":"conda install -n myenv pip conda activate myenv pip <pip_subcommand>","title":"Usar pip em um env"},{"location":"Conda/#clonando-um-enviroment","text":"conda create --name myclone --clone myenv","title":"Clonando um enviroment"},{"location":"Conda/#remover-um-env","text":"conda remove --name myenv --all","title":"Remover um Env"},{"location":"Flask/","text":"Introdu\u00e7\u00e3o Features do Flask Micro-framework O Modelo Arquitetural Cliente-Servidor Comunica\u00e7\u00e3o cliente servidor Uma aplica\u00e7\u00e3o Flask como um servidor Arquitetura Model-Template-View (MTV) Componentes da Arquitetura MVC MTV WSGI e Jinja2 Web Server Gateway Interface (WSGI) A linguagem de template Jinja Hello World! Passo 1: Importando M\u00f3dulos Passo 2: Criando um objeto Flask Passo 3: Executar a aplica\u00e7\u00e3o em main Passo 4: Criar uma fun\u00e7\u00e3o view Passo 5: Atribuir uma rota URL Implementa\u00e7\u00e3o completa Rotas URL e Views O decorator route() Static Routing Um Exemplo usando rotas URL est\u00e1ticas Dynamic Routing Variable Rules Exemplo usando rules vari\u00e1veis Converter Como usar Templates HTML Templates Est\u00e1ticos Renderizando templates HTML Uma String Fun\u00e7\u00e3o render_template Estrat\u00e9gias de estrutura de arquivos Estrutura de arquivos em m\u00f3dulo Estrutura de arquivo em pacotes Arquivos Est\u00e1ticos Como Servimos Arquivos Est\u00e1ticos? Passos para servir Arquivos Est\u00e1ticos Criar um diret\u00f3rio \\static Criar uma URL para arquivos est\u00e1ticos Fun\u00e7\u00e3o url_for() Exemplo Templates Din\u00e2micos Templates Jinja2 A Engine de Template Jinja Delimitadores Vari\u00e1veis Fluxo de controle com Jinja Loops Condicionais Template Inheritance Blocks base.html home.html about.html Forms Utilizando Request Data Handling usando objeto Request Recebendo o tipo de method de request. Recebendo Form data de request Exemplo com L\u00f3gica de Valida\u00e7\u00e3o Criando Formul\u00e1rios usando Flask-WTF e WTForms Renderizando formul\u00e1rios Flask-WTF em templates Aprendendo Flask Introdu\u00e7\u00e3o Flask \u00e9 um framework de desenvolvimento web desenvolvido em Python. \u00c9 f\u00e1cil de aprender e de usar. \"Begginer-friendly\" porque n\u00e3o usa c\u00f3digos que devem ser sempre copiados ou depend\u00eancias, o que pode distrair da fun\u00e7\u00e3o prim\u00e1ria da aplica\u00e7\u00e3o. Features do Flask Fornece um servidor de desenvolvimento e um debugger. Usa templates Jinja2. Compat\u00edvel com WSGI 1.0. Fornece suporte integrado para testes unit\u00e1rios. Muitas extens\u00f5es dispon\u00edveis. Micro-framework Oposto a fullstack framework, que tamb\u00e9m oferecem m\u00f3dulos adicionais features como autentica\u00e7\u00e3o, banco de dados ORM, valida\u00e7\u00e3o de input e sanitiza\u00e7\u00e3o, etc... Flask \u00e9 conhecido como um micro-framework porque \u00e9 leve e apenas fornece componentes que s\u00e3o essenciais, como routing, request, handling, sessions . Para outras funcionalidades o desenvolvedor deve escrever m\u00f3dulos customizados ou usar uma extens\u00e3o. Essa abordagem evita boilerplate code. O Modelo Arquitetural Cliente-Servidor Cliente : Enviar requisi\u00e7\u00e3o para os servidores e enviar de volta os dados necess\u00e1rios. Servidor : Espera por requisi\u00e7\u00f5es dos clientes e responde a elas. O servidor responde a essas requisi\u00e7\u00f5es e envia a informa\u00e7\u00e3o que o cliente pediu. Comunica\u00e7\u00e3o cliente servidor Atrav\u00e9s de m\u00faltiplos protocolos diferentes. Em nosso contexto, HTTP ou HTTPS s\u00e3o usados. M\u00e9todos HTTP: GET POST PUT DELETE Uma aplica\u00e7\u00e3o Flask como um servidor A aplica\u00e7\u00e3o Flask aqui ser\u00e1 do lado servidor. o Browser agir\u00e1 como cliente mandando requisi\u00e7\u00f5es para nossa aplica\u00e7\u00e3o web. Ent\u00e3o a aplica\u00e7\u00e3o enviar\u00e1 a resposta apropriada. Arquitetura Model-Template-View (MTV) A arquitetura MTV \u00e9 uma varia\u00e7\u00e3o da arquitetura do MVC ( Model-View-Controler ). A arquitetura MVC \u00e9 um padr\u00e3o arquitetural de software no qual a l\u00f3gica da aplica\u00e7\u00e3o \u00e9 dividida em 3 componentes na base da funcionalidade: Models Views Controllers \u00c9 usado n\u00e3o apenas para aplica\u00e7\u00f5es Desktop como tamb\u00e9m para Web e Mobile. Componentes da Arquitetura MVC Models Models representam como os dados s\u00e3o armazenados no banco de dados. Cont\u00e9m todas as defini\u00e7\u00f5es de dados para a aplica\u00e7\u00e3o (o schema). Views Views s\u00e3o componentes que s\u00e3o vis\u00edveis ao usu\u00e1rio, como um output ou um Graphical User Interface (GUI). Controllers Controllers s\u00e3o componentes que agem como uma interface entre models e views . O controller interpreta as intera\u00e7\u00f5es do usu\u00e1rio (inputs) e executa tarefas nos models antes de retornar os dados apropriados atrav\u00e9s dos views. MTV A arquitetura MTV \u00e9 uma leve varia\u00e7\u00e3o da MVC . Por si s\u00f3, Flask \u00e9 um micro framwork e n\u00e3o cont\u00e9m suporte built-in para nenhum framework arquitetural. Entretanto, programadores que usam Flask t\u00eam a arquitetura MTV porque outro framework de desenvolvimento web baseado em Python, chamado Django a introduziu. Abaixo, uma compara\u00e7\u00e3o grosseira entre MVC e MTV: WSGI e Jinja2 Web Server Gateway Interface (WSGI) WSGI \u00e9 um padr\u00e3o que descreve as especifica\u00e7\u00f5es concernentes \u00e0 comunica\u00e7\u00e3o entre um servidor web e uma aplica\u00e7\u00e3o cliente. Os detalhes desse padr\u00e3o est\u00e3o presentes na PEP33. Alguns benef\u00edcios do WSGI: Flexibilidade com os componentes da aplica\u00e7\u00e3o. Interoperabilidade entre diferentes frameworks Python. Escalabilidade da aplica\u00e7\u00e3o com o aumento de usu\u00e1rios. Efici\u00eancia em termos de velocidade de desenvolvimento. N\u00e3o precisamos nos preocupar com detalhes internos do WSGI porque o modulo Flask lida com isso. A linguagem de template Jinja Jinja \u00e9 uma linguagem de template usada em Python. Podemos renderizar conte\u00fado din\u00e2mico em HTML usando Jinja. Hello World! A aplica\u00e7\u00e3o mais simples em Flask pode ser feita usando apenas um script. Chamaremos de app.py . O programa ser\u00e1 dividido em passos. Passo 1: Importando M\u00f3dulos Para essa aplica\u00e7\u00e3o, precisamos apenas do m\u00f3dulo Flask da biblioteca flask. from flask import Flask Passo 2: Criando um objeto Flask Precisamos criar um objeto com o modulo importado Flask. Esse objeto ser\u00e1 nossa aplica\u00e7\u00e3o WSGI chamada app . app = Flask(__name__) Passo 3: Executar a aplica\u00e7\u00e3o em main Para executar a aplica\u00e7\u00e3o, chamaremos a fun\u00e7\u00e3o run() do nosso objeto app. if __name__ == \"__main__\": app.run() Passo 4: Criar uma fun\u00e7\u00e3o view Antes de rodar a aplica\u00e7\u00e3o, precisamos dizer \u00e0 aplica\u00e7\u00e3o para mostrar algo como sa\u00edda no browser. Ent\u00e3o, criamos uma fun\u00e7\u00e3o chamada hello() que retorna a string \"Hello World!\". A sa\u00edda retornada desta fun\u00e7\u00e3o ser\u00e1 mostrada no browser. def hello(): return \"Hello World\"; Passo 5: Atribuir uma rota URL Finalmente, precisamos dizer ao app Flask quando chamar a fun\u00e7\u00e3o view hello() . Para este prop\u00f3sito, criaremos uma rota URL. Uma rota URL \u00e9 associada a cada fun\u00e7\u00e3o view. Essa associa\u00e7\u00e3o \u00e9 criada usando o decorator route() antes de cada fun\u00e7\u00e3o view. @app.route(\"/\") def hello(): return \"Hello World!\"; Implementa\u00e7\u00e3o completa from flask import Flask app = Flask(__name__) @app.route(\"/\") def hello(): return \"Hello World!\"; if __name__ == \"__main__\": app.run(debug = True, host = \"0.0.0.0\", port = 3000) Rotas URL e Views A homepage de um website pode ser facilmente achada na URL hostname seguida de / , /home , /index ou algo auto explicativo. Estes tipos de URLs permitem que os usu\u00e1rios lembrem da URL e acessem facilmente. Seria inesperado se uma homepage fosse em uma URL aleat\u00f3ria como /39283@&3911 ou /more_eggs . Flask nos permite usar o decorator route() para vincular uma URL significativa a cada fun\u00e7\u00e3o view que criarmos. O decorator route() O decorator route leva os seguintes par\u00e2metros: rule : representa a regra de URL que \u00e9 passada como string ao decorador. endpoint (n\u00e3o necess\u00e1rio): \u00c9 o nome da fun\u00e7\u00e3o de view que \u00e9 vinculada a rota URL. options (n\u00e3o necess\u00e1rio): Par\u00e2metro opcional. Static Routing Em roteamento est\u00e1tico, especificamos uma string URL constante como uma regra para o decorator route() . Na aplica\u00e7\u00e3o abaixo especificamos duas rotas est\u00e1ticas tendo URLs / e educative , respectivamente. Nota : A rule \u00e9 uma string case-sensitive. Portanto, educative e Educative s\u00e3o URLs totalmente diferentes. Um Exemplo usando rotas URL est\u00e1ticas from flask import Flask, render_template app = Flask(__name__) @app.route(\"/\") def home(): return \"Welcome to the HomePage!\" @app.route(\"/educative\") def learn(): return \"Happy Learning at Educative!\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000) Dynamic Routing Em roteamento din\u00e2mico, o par\u00e2metro rule n\u00e3o \u00e9 uma string constante e sim uma vari\u00e1vel . Variable Rules Em Flask podemos adicionar rules vari\u00e1veis dentro da rota URL ao usar a seguinte sintaxe: <variable_name> . A vari\u00e1vel chamada variable_name ser\u00e1 ent\u00e3o passada \u00e0 fun\u00e7\u00e3o view para ser usada. Exemplo usando rules vari\u00e1veis from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"Welcome to the HomePage!\" @app.route(\"/<my_name>\") def greatings(my_name): return \"Welcome \"+ my_name +\"!\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000) Converter No exemplo anterior, a vari\u00e1vel my_name foi extra\u00edda da URL e foi convertida em uma string e passada para a fun\u00e7\u00e3o greetings() para ser usada. Este \u00e9 o comportamento padr\u00e3o do converter . @app.route('/square/<int:number>') def show_square(number): \"\"\"View that shows the square of the number passed by URL\"\"\" return \"Square of \"+ str(number) +\" is: \"+ str(number * number) Como usar Templates HTML Templates Est\u00e1ticos S\u00e3o arquivos HTML que permanecem constantes. De fato, arquivos HTML padr\u00e3o s\u00e3o est\u00e1ticos por natureza. Sempre que o mesmo arquivo \u00e9 renderizado, ele mostra o mesmo output, a menos que o arquivo seja alterado. At\u00e9 agora, estamos retornando apenas uma string de uma fun\u00e7\u00e3o view. Mas em uma aplica\u00e7\u00e3o do mundo real, esperamos que um arquivo HTML seja retornado e renderizado no tela do browser. Renderizando templates HTML HTML pode ser renderizado com Flask usando dois m\u00e9todos. Uma String Podemos utilizar HTML como uma string em uma fun\u00e7\u00e3o view. from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"<h1>Welcome to the HomePage!</h1>\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000) Fun\u00e7\u00e3o render_template Retornar HTML como uma String funciona perfeitamente, mas n\u00e3o \u00e9 apropriado para aplica\u00e7\u00f5es pr\u00e1ticas. \u00c9 melhor manter c\u00f3digo e templates separados. Portanto, criamos arquivos separados contendo o c\u00f3digo HTML para os templates. Ent\u00e3o, estes arquivos HTML pode ser referenciados para dentro dos views pelos seus nomes. Flask cont\u00e9m uma fun\u00e7\u00e3o chamada render_template() que \u00e9 usada para renderizar os templates HTML desejados. Este m\u00e9todo tem os seguintes par\u00e2metros: template_name_or_list : O nome do template ou de uma lista de templates (o m\u00e9todo vai renderizar o primeiro template da lista). context (opcional): vari\u00e1vel que devem estar dispon\u00edveis dentro do template. O output de render_template() ent\u00e3o \u00e9 retornado pela view ao inv\u00e9s de uma simples String, como est\u00e1vamos fazendo previamente. def view_name(): return render_template(template_name) Estrat\u00e9gias de estrutura de arquivos O framework Flask procura pelos arquivos de template HTML dentro de um diret\u00f3rio nomeado \\templates . Este diret\u00f3rio deve ser posto de forma que Flask possa encontrar. Estrutura de arquivos em m\u00f3dulo Se seguir uma estrutura de arquivos modular em nosso projeto, um diret\u00f3rio separado chamado \"templates\" pode ser criado no mesmo diret\u00f3rio que o m\u00f3dulo principal da aplica\u00e7\u00e3o. (ex: app.py ). Estrutura de arquivo em pacotes Se a l\u00f3gica da aplica\u00e7\u00e3o est\u00e1 dividida em m\u00f3dulos separados, ent\u00e3o estes arquivos est\u00e3o presentes no mesmo pacote. Em Python, um pacote \u00e9 simplesmente um diret\u00f3rio contendo um arquivo nomeado como __init__.py . Se esta estrutura esta sendo seguida em nossa aplica\u00e7\u00e3o, ent\u00e3o iremos criar o diret\u00f3rio templates dentro do pacote da aplica\u00e7\u00e3o principal. Arquivos Est\u00e1ticos Como Servimos Arquivos Est\u00e1ticos? Arquivos est\u00e1ticos (ou assets), s\u00e3o arquivos que o servidor manda para o cliente \"como eles s\u00e3o\", sem qualquer interven\u00e7\u00e3o. Por exemplo, qualquer arquivo css , ou JavaScript que podemos ter em nosso website s\u00e3o enviados para o cliente sem qualquer modifica\u00e7\u00e3o. Passos para servir Arquivos Est\u00e1ticos Os passos a seguir s\u00e3o necess\u00e1rios para hospedar um asset est\u00e1tico. Criar um diret\u00f3rio \\static As mesmas estrat\u00e9gias de estruturas de arquivos tamb\u00e9m se aplicam aqui. Criar uma URL para arquivos est\u00e1ticos N\u00e3o usamos views para arquivos est\u00e1ticos. Ent\u00e3o, para criar uma URL separada para eles, usamos a fun\u00e7\u00e3o url_for() . Fun\u00e7\u00e3o url_for() A fun\u00e7\u00e3o url_for() \u00e9 usada para criar uma URL para certo endpoint. Podemos us\u00e1-la para criar URLs para views tamb\u00e9m. Ela leva o nome do endpoint e quaisquer vari\u00e1veis associadas como argumentos. url_for('view_function_name', variable_name = 'value_of_variable') \ud83e\udd14 Porque precisamos usar url_for() se podemos escrever a URL? A fun\u00e7\u00e3o url_for() sempre retorna a URL absoluta para o endpoint. Portanto, chamamos ela em qualquer lugar do projeto e n\u00e3o teremos problemas com caminhos relativos. Se acabarmos mudando o caminho para um endpoint ou rota para uma view, n\u00e3o temos que mudar a URL escrita em todo o projeto. A URL para um arquivo est\u00e1tico pode ser criada usando um endpoint static como a seguir: url_for('static', filename = 'name_of_file') Exemplo <!DOCTYPE html> <html> <head> <link rel=\"stylesheet\" href=\"{{url_for('static', filename='borders.css')}}\" /> </head> <body> <h1>Home Page!</h1> <p>Welcome to the homepage for \"How to Server Static Files\" Demo!</p> </body> </html> Chaves duplas fazem parte da sintaxe de Jinja Templates Din\u00e2micos Templates Jinja2 Considere que estamos fazendo uma aplica\u00e7\u00e3o com m\u00faltiplos usu\u00e1rios, tal como uma rede social, cada usu\u00e1rio ter\u00e1 um perfil \u00fanico com informa\u00e7\u00f5es \u00fanicas associadas a ele. \u00c9 nosso trabalho na aplica\u00e7\u00e3o web servir um template \u00fanico contendo o conte\u00fado correspondente a usu\u00e1rio que est\u00e1 logado. Podemos observar, que do lado do servidor, um template gen\u00e9rico est\u00e1 colocado contendo uma variable rule . Quando este template \u00e9 renderizado no lado do cliente, uma valor apropriado \u00e9 colocado ao inv\u00e9s da rule . Esse novo valor \u00e9 de acordo com o contexto da aplica\u00e7\u00e3o. Este tipo de comportamento din\u00e2mico de um template \u00e9 chamado de dynamic templating . Muitas tecnologias server-side nos permitem implementar comportamento de template din\u00e2mico. Flask tem suporte embutido para uma engine para cria\u00e7\u00e3o de templates din\u00e2micos chamada Jinja . A Engine de Template Jinja Um arquivo de template Jinja \u00e9 um arquivo de texto que n\u00e3o tem uma extens\u00e3o em particular. Usaremos extens\u00e3o .html com os arquivos de template porque eles tamb\u00e9m ir\u00e3o incluir sintaxe HTML . Delimitadores {% ... %} \u00e9 usado para declara\u00e7\u00f5es. {{ ... }} \u00e9 usado para vari\u00e1veis. {# ... #} \u00e9 usado para coment\u00e1rios. # ... ## \u00e9 usado para declara\u00e7\u00f5es de linha. Vari\u00e1veis Podemos inserir vari\u00e1veis dentro de templates seguindo estes dois passos: 1 . O objeto \u00e9 fornecido com um argumento nomeado para a fun\u00e7\u00e3o render_template() . return render_template(\"index.html\", my_object = Object) O valor desse objeto \u00e9 buscado dentro do template usando a sintaxe {{}} . {{ my_object }} Fluxo de controle com Jinja Jinja tamb\u00e9m fornece sintaxe para lidar com fluxo de controle de um aplica\u00e7\u00e3o dentro dos seus templates. Loops e condi\u00e7\u00f5es podem ser adicionadas aos templates utilizando a sintaxe pythonica fornecida pelo Jinja. Loops A sintaxe de for \u00e9 bem parecida com a de python. {% for elements in array %} ... {% endfor %} Condicionais {% if true %} {% endif %} M\u00faltiplas ramifica\u00e7\u00f5es utilizando elif e else . {% if ... %} {% elif ... %} {% else %} {% endif %} Template Inheritance Blocks Em Jinja, blocks s\u00e3o usados como placeholders e tamb\u00e9m como substitutos. No template pai , estes blocos s\u00e3o usados como placeholders . Enquanto que no template filho, eles s\u00e3o usados como substitutos. base.html <!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"{{url_for('static', filename='format.css')}}\" /> <title>{% block title %}<!-- Placeholder for Title -->{% endblock %} - Jinja Demo</title> {% block head %} <!-- Placeholder for Other Imports --> {% endblock %} </head> <body> <div id=\"header\"> JINJA DEMO </div> <div id=\"content\"> {% block content %} <!-- Placeholder for Page Content --> {% endblock %} </div> <div id=\"footer\"> Copyright \u00a9 2019 All Rights Reserved </div> </body> </html> home.html {% extends \"base.html\" %} <!-- Replacement for Title --> {% block title %} Home Page {% endblock %} <!-- Replacement for Content --> {% block content %} <h1>Home Page</h1> <p>Welcome to the Jinja2 Demo.</p> {% endblock %} about.html {% extends \"base.html\" %} <!-- Replacement for Title --> {% block title %} About Page {% endblock %} <!-- Replacement for Content --> {% block content %} <h1>About Page</h1> <p>In this lesson we are learning about Template Inheritance</p> {% endblock %} Forms O pacote Flask n\u00e3o fornece uma forma de lidar com formul\u00e1rios. Existem duas formas que desenvolvedor lidam com isso: Via objeto request . Via extens\u00e3o Flask-WTF . Utilizando Request Por padr\u00e3o, o decorator route() serve apenas requisi\u00e7\u00f5es get . Portanto, devemos fornecer um par\u00e2metro extra, chamado methods para o decorator route() . @app.route(\"/login\", methods=[\"GET\", \"POST\"]) login.html {% block content %} <h1>Login</h1> <form action=\"{{url_for('login')}}\" method=\"POST\"> Email:<br> <input type=\"text\" name=\"email\" > <br> Password:<br> <input type=\"password\" name=\"password\" > <br><br> <input type=\"submit\" value=\"Login\"> </form> {% endblock %} Data Handling usando objeto Request Para acessar dados enviados pelo usu\u00e1rio usamos o objeto global request . from flask import request Recebendo o tipo de method de request. Podemos utilizar o atributo method do objeto request para determinar o m\u00e9todo de um requisi\u00e7\u00e3o entrante. @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": ... else ... return render_template(\"login.html\") Recebendo Form data de request Podemos usar o atributo form de um objeto request para obter os valores que o usu\u00e1rio submeteu. a form \u00e9 uma estrutura de dados especial chamado ImmutableMultiDict . @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": email = request.form[\"email\"] password = request.form[\"password\"] ... else: ... return render_template(\"login.html\") Exemplo com L\u00f3gica de Valida\u00e7\u00e3o from flask import Flask, render_template from flask import request app = Flask(__name__) users = { \"archie.andrews@email.com\": \"football4life\", \"veronica.lodge@email.com\": \"fashiondiva\" } @app.route(\"/\") def home(): return render_template(\"home.html\") @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": email = request.form[\"email\"] password = request.form[\"password\"] if email in users and users[email] == password: return render_template(\"login.html\", message =\"Successfully Logged In\") return render_template(\"login.html\", message =\"Incorrect Email or Password\") return render_template(\"login.html\") if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000) login.html {% block content %} <h1>Login</h1> {% if message %} {{ message }} {% endif %} <form action=\"{{url_for('login')}}\" method=\"POST\"> Email:<br> <input type=\"text\" name=\"email\" > <br> Password:<br> <input type=\"password\" name=\"password\" > <br><br> <input type=\"submit\" value=\"Login\"> </form> <hr> {% endblock %} Criando Formul\u00e1rios usando Flask-WTF e WTForms Em nossa aplica\u00e7\u00e3o n\u00e3o t\u00ednhamos nenhuma checagem para email e password porque era um exemplo simples. Se quisermos adicionar esses checks dever\u00edamos escreve l\u00f3gica para isso no front end ou no backend (dentro da view login ). Em aplica\u00e7\u00f5es maiores esses tipos de componentes extras podem facilmente se tornar boiler-plate e dif\u00edcil de ler, para esse prop\u00f3sito algumas biblioteca tornam este processo mais f\u00e1cil. WTForms : \u00c9 um biblioteca que torna trabalhar com formul\u00e1rios f\u00e1cil. Ela lida n\u00e3o apenas com valida\u00e7\u00e3o mas tamb\u00e9m com a renderiza\u00e7\u00e3o no front-end. Adicionalmente, WTForms n\u00e3o \u00e9 limitada somente a Flask. Flask-WTF : \u00c9 uma biblioteca espec\u00edfica de Flask que integra a biblioteca WTForm com Flask . Age como um add-on de WTForms e adiciona alguns componentes extra, como seguran\u00e7a. Criando um m\u00f3dulo forms: Primeiro, separamos nosso m\u00f3dulo da aplica\u00e7\u00e3o do m\u00f3dulo dos formul\u00e1rios. Adicionaremos um novo arquivo chamado forms.py , que agir\u00e1 como um m\u00f3dulo de formul\u00e1rios. Importando FlaskForm de flask_wtf : from flask_wtf import FlaskForm # Essa classe \u00e9 uma subclasse de Form da bilioteca wtforms Criando classe LoginForm : Para cada formul\u00e1rio em nosso website, criaremos uma classe a medida em que estamos criando um formul\u00e1rio de login. Portanto, vamos nomear essa classe LoginForm . Esta classe ir\u00e1 herdar da classe FlaskForm importada previamente. class LoginForm(FlaskForm): ... Adicionando campos de formul\u00e1rio de wtforms O formul\u00e1rio de login anterior tinha 3 componentes: Um campo de input para email. Um campo de input para password. O campo do bot\u00e3o submit. Para todo campo poss\u00edvel, wtforms tem classes associadas. Para este exemplo particular, importaremos apenas os campos que precisamos: StringField para email. PasswordField para um password. SubmitField para o bot\u00e3o submit. from wtforms import StringField, PasswordField, SubmitField Agora vamos criar inst\u00e2ncias dessas classes como vari\u00e1veis membros da nossa classe e iremos passar os r\u00f3tulos desses campos como inputs para os construtores. class LoginForm(FlaskForm): email = StringField('Email') password = PasswordField('Password') submit = SubmitField('Login') Adicionar validadores de campo do wtforms : Validadores s\u00e3o regras e checks que queremos aplicar aos nossos campos dentro de um formul\u00e1rio. Por exemplo, em um campo de email queremos ter certeza de que o input \u00e9 um email v\u00e1lido. Para esse prop\u00f3sito iremos usar o validador Email . from wtforms.validators import InputRequired, Email Para aplicar estes validadores aos campos, fornecemos uma lista de validadores como par\u00e2metros a eles: class LoginForm(FlaskForm): email = StringField('Email', validators=[InputRequired(), Email()]) password = PasswordField('Password', validators=[InputRequired()]) submit = SubmitField('Login') InputRequired(): coloca o atributo required no HTML. Email() : checa se o input \u00e9 um email v\u00e1lido. Implementa\u00e7\u00e3o completa from flask_wtf import FlaskForm from wtforms import StringField, PasswordField, SubmitField from wtforms.validators import InputRequired, Email class LoginForm(FlaskForm): email = StringField('Email', validators=[InputRequired(), Email()]) password = PasswordField('Password', validators=[InputRequired()]) submit = SubmitField('Login') Renderizando formul\u00e1rios Flask-WTF em templates","title":"Flask"},{"location":"Flask/#introducao","text":"Flask \u00e9 um framework de desenvolvimento web desenvolvido em Python. \u00c9 f\u00e1cil de aprender e de usar. \"Begginer-friendly\" porque n\u00e3o usa c\u00f3digos que devem ser sempre copiados ou depend\u00eancias, o que pode distrair da fun\u00e7\u00e3o prim\u00e1ria da aplica\u00e7\u00e3o.","title":"Introdu\u00e7\u00e3o"},{"location":"Flask/#features-do-flask","text":"Fornece um servidor de desenvolvimento e um debugger. Usa templates Jinja2. Compat\u00edvel com WSGI 1.0. Fornece suporte integrado para testes unit\u00e1rios. Muitas extens\u00f5es dispon\u00edveis.","title":"Features do Flask"},{"location":"Flask/#micro-framework","text":"Oposto a fullstack framework, que tamb\u00e9m oferecem m\u00f3dulos adicionais features como autentica\u00e7\u00e3o, banco de dados ORM, valida\u00e7\u00e3o de input e sanitiza\u00e7\u00e3o, etc... Flask \u00e9 conhecido como um micro-framework porque \u00e9 leve e apenas fornece componentes que s\u00e3o essenciais, como routing, request, handling, sessions . Para outras funcionalidades o desenvolvedor deve escrever m\u00f3dulos customizados ou usar uma extens\u00e3o. Essa abordagem evita boilerplate code.","title":"Micro-framework"},{"location":"Flask/#o-modelo-arquitetural-cliente-servidor","text":"Cliente : Enviar requisi\u00e7\u00e3o para os servidores e enviar de volta os dados necess\u00e1rios. Servidor : Espera por requisi\u00e7\u00f5es dos clientes e responde a elas. O servidor responde a essas requisi\u00e7\u00f5es e envia a informa\u00e7\u00e3o que o cliente pediu.","title":"O Modelo Arquitetural Cliente-Servidor"},{"location":"Flask/#comunicacao-cliente-servidor","text":"Atrav\u00e9s de m\u00faltiplos protocolos diferentes. Em nosso contexto, HTTP ou HTTPS s\u00e3o usados. M\u00e9todos HTTP: GET POST PUT DELETE","title":"Comunica\u00e7\u00e3o cliente servidor"},{"location":"Flask/#uma-aplicacao-flask-como-um-servidor","text":"A aplica\u00e7\u00e3o Flask aqui ser\u00e1 do lado servidor. o Browser agir\u00e1 como cliente mandando requisi\u00e7\u00f5es para nossa aplica\u00e7\u00e3o web. Ent\u00e3o a aplica\u00e7\u00e3o enviar\u00e1 a resposta apropriada.","title":"Uma aplica\u00e7\u00e3o Flask como um servidor"},{"location":"Flask/#arquitetura-model-template-view-mtv","text":"A arquitetura MTV \u00e9 uma varia\u00e7\u00e3o da arquitetura do MVC ( Model-View-Controler ). A arquitetura MVC \u00e9 um padr\u00e3o arquitetural de software no qual a l\u00f3gica da aplica\u00e7\u00e3o \u00e9 dividida em 3 componentes na base da funcionalidade: Models Views Controllers \u00c9 usado n\u00e3o apenas para aplica\u00e7\u00f5es Desktop como tamb\u00e9m para Web e Mobile.","title":"Arquitetura Model-Template-View (MTV)"},{"location":"Flask/#componentes-da-arquitetura-mvc","text":"Models Models representam como os dados s\u00e3o armazenados no banco de dados. Cont\u00e9m todas as defini\u00e7\u00f5es de dados para a aplica\u00e7\u00e3o (o schema). Views Views s\u00e3o componentes que s\u00e3o vis\u00edveis ao usu\u00e1rio, como um output ou um Graphical User Interface (GUI). Controllers Controllers s\u00e3o componentes que agem como uma interface entre models e views . O controller interpreta as intera\u00e7\u00f5es do usu\u00e1rio (inputs) e executa tarefas nos models antes de retornar os dados apropriados atrav\u00e9s dos views.","title":"Componentes da Arquitetura MVC"},{"location":"Flask/#mtv","text":"A arquitetura MTV \u00e9 uma leve varia\u00e7\u00e3o da MVC . Por si s\u00f3, Flask \u00e9 um micro framwork e n\u00e3o cont\u00e9m suporte built-in para nenhum framework arquitetural. Entretanto, programadores que usam Flask t\u00eam a arquitetura MTV porque outro framework de desenvolvimento web baseado em Python, chamado Django a introduziu. Abaixo, uma compara\u00e7\u00e3o grosseira entre MVC e MTV:","title":"MTV"},{"location":"Flask/#wsgi-e-jinja2","text":"","title":"WSGI e Jinja2"},{"location":"Flask/#web-server-gateway-interface-wsgi","text":"WSGI \u00e9 um padr\u00e3o que descreve as especifica\u00e7\u00f5es concernentes \u00e0 comunica\u00e7\u00e3o entre um servidor web e uma aplica\u00e7\u00e3o cliente. Os detalhes desse padr\u00e3o est\u00e3o presentes na PEP33. Alguns benef\u00edcios do WSGI: Flexibilidade com os componentes da aplica\u00e7\u00e3o. Interoperabilidade entre diferentes frameworks Python. Escalabilidade da aplica\u00e7\u00e3o com o aumento de usu\u00e1rios. Efici\u00eancia em termos de velocidade de desenvolvimento. N\u00e3o precisamos nos preocupar com detalhes internos do WSGI porque o modulo Flask lida com isso.","title":"Web Server Gateway Interface (WSGI)"},{"location":"Flask/#a-linguagem-de-template-jinja","text":"Jinja \u00e9 uma linguagem de template usada em Python. Podemos renderizar conte\u00fado din\u00e2mico em HTML usando Jinja.","title":"A linguagem de template Jinja"},{"location":"Flask/#hello-world","text":"A aplica\u00e7\u00e3o mais simples em Flask pode ser feita usando apenas um script. Chamaremos de app.py . O programa ser\u00e1 dividido em passos.","title":"Hello World!"},{"location":"Flask/#passo-1-importando-modulos","text":"Para essa aplica\u00e7\u00e3o, precisamos apenas do m\u00f3dulo Flask da biblioteca flask. from flask import Flask","title":"Passo 1: Importando M\u00f3dulos"},{"location":"Flask/#passo-2-criando-um-objeto-flask","text":"Precisamos criar um objeto com o modulo importado Flask. Esse objeto ser\u00e1 nossa aplica\u00e7\u00e3o WSGI chamada app . app = Flask(__name__)","title":"Passo 2: Criando um objeto Flask"},{"location":"Flask/#passo-3-executar-a-aplicacao-em-main","text":"Para executar a aplica\u00e7\u00e3o, chamaremos a fun\u00e7\u00e3o run() do nosso objeto app. if __name__ == \"__main__\": app.run()","title":"Passo 3: Executar a aplica\u00e7\u00e3o em main"},{"location":"Flask/#passo-4-criar-uma-funcao-view","text":"Antes de rodar a aplica\u00e7\u00e3o, precisamos dizer \u00e0 aplica\u00e7\u00e3o para mostrar algo como sa\u00edda no browser. Ent\u00e3o, criamos uma fun\u00e7\u00e3o chamada hello() que retorna a string \"Hello World!\". A sa\u00edda retornada desta fun\u00e7\u00e3o ser\u00e1 mostrada no browser. def hello(): return \"Hello World\";","title":"Passo 4: Criar uma fun\u00e7\u00e3o view"},{"location":"Flask/#passo-5-atribuir-uma-rota-url","text":"Finalmente, precisamos dizer ao app Flask quando chamar a fun\u00e7\u00e3o view hello() . Para este prop\u00f3sito, criaremos uma rota URL. Uma rota URL \u00e9 associada a cada fun\u00e7\u00e3o view. Essa associa\u00e7\u00e3o \u00e9 criada usando o decorator route() antes de cada fun\u00e7\u00e3o view. @app.route(\"/\") def hello(): return \"Hello World!\";","title":"Passo 5: Atribuir uma rota URL"},{"location":"Flask/#implementacao-completa","text":"from flask import Flask app = Flask(__name__) @app.route(\"/\") def hello(): return \"Hello World!\"; if __name__ == \"__main__\": app.run(debug = True, host = \"0.0.0.0\", port = 3000)","title":"Implementa\u00e7\u00e3o completa"},{"location":"Flask/#rotas-url-e-views","text":"A homepage de um website pode ser facilmente achada na URL hostname seguida de / , /home , /index ou algo auto explicativo. Estes tipos de URLs permitem que os usu\u00e1rios lembrem da URL e acessem facilmente. Seria inesperado se uma homepage fosse em uma URL aleat\u00f3ria como /39283@&3911 ou /more_eggs . Flask nos permite usar o decorator route() para vincular uma URL significativa a cada fun\u00e7\u00e3o view que criarmos.","title":"Rotas URL e Views"},{"location":"Flask/#o-decorator-route","text":"O decorator route leva os seguintes par\u00e2metros: rule : representa a regra de URL que \u00e9 passada como string ao decorador. endpoint (n\u00e3o necess\u00e1rio): \u00c9 o nome da fun\u00e7\u00e3o de view que \u00e9 vinculada a rota URL. options (n\u00e3o necess\u00e1rio): Par\u00e2metro opcional.","title":"O decorator route()"},{"location":"Flask/#static-routing","text":"Em roteamento est\u00e1tico, especificamos uma string URL constante como uma regra para o decorator route() . Na aplica\u00e7\u00e3o abaixo especificamos duas rotas est\u00e1ticas tendo URLs / e educative , respectivamente. Nota : A rule \u00e9 uma string case-sensitive. Portanto, educative e Educative s\u00e3o URLs totalmente diferentes.","title":"Static Routing"},{"location":"Flask/#um-exemplo-usando-rotas-url-estaticas","text":"from flask import Flask, render_template app = Flask(__name__) @app.route(\"/\") def home(): return \"Welcome to the HomePage!\" @app.route(\"/educative\") def learn(): return \"Happy Learning at Educative!\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000)","title":"Um Exemplo usando rotas URL est\u00e1ticas"},{"location":"Flask/#dynamic-routing","text":"Em roteamento din\u00e2mico, o par\u00e2metro rule n\u00e3o \u00e9 uma string constante e sim uma vari\u00e1vel .","title":"Dynamic Routing"},{"location":"Flask/#variable-rules","text":"Em Flask podemos adicionar rules vari\u00e1veis dentro da rota URL ao usar a seguinte sintaxe: <variable_name> . A vari\u00e1vel chamada variable_name ser\u00e1 ent\u00e3o passada \u00e0 fun\u00e7\u00e3o view para ser usada.","title":"Variable Rules"},{"location":"Flask/#exemplo-usando-rules-variaveis","text":"from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"Welcome to the HomePage!\" @app.route(\"/<my_name>\") def greatings(my_name): return \"Welcome \"+ my_name +\"!\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000)","title":"Exemplo usando rules vari\u00e1veis"},{"location":"Flask/#converter","text":"No exemplo anterior, a vari\u00e1vel my_name foi extra\u00edda da URL e foi convertida em uma string e passada para a fun\u00e7\u00e3o greetings() para ser usada. Este \u00e9 o comportamento padr\u00e3o do converter . @app.route('/square/<int:number>') def show_square(number): \"\"\"View that shows the square of the number passed by URL\"\"\" return \"Square of \"+ str(number) +\" is: \"+ str(number * number)","title":"Converter"},{"location":"Flask/#como-usar-templates-html","text":"","title":"Como usar Templates HTML"},{"location":"Flask/#templates-estaticos","text":"S\u00e3o arquivos HTML que permanecem constantes. De fato, arquivos HTML padr\u00e3o s\u00e3o est\u00e1ticos por natureza. Sempre que o mesmo arquivo \u00e9 renderizado, ele mostra o mesmo output, a menos que o arquivo seja alterado. At\u00e9 agora, estamos retornando apenas uma string de uma fun\u00e7\u00e3o view. Mas em uma aplica\u00e7\u00e3o do mundo real, esperamos que um arquivo HTML seja retornado e renderizado no tela do browser.","title":"Templates Est\u00e1ticos"},{"location":"Flask/#renderizando-templates-html","text":"HTML pode ser renderizado com Flask usando dois m\u00e9todos.","title":"Renderizando templates HTML"},{"location":"Flask/#uma-string","text":"Podemos utilizar HTML como uma string em uma fun\u00e7\u00e3o view. from flask import Flask app = Flask(__name__) @app.route(\"/\") def home(): return \"<h1>Welcome to the HomePage!</h1>\" if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000)","title":"Uma String"},{"location":"Flask/#funcao-render_template","text":"Retornar HTML como uma String funciona perfeitamente, mas n\u00e3o \u00e9 apropriado para aplica\u00e7\u00f5es pr\u00e1ticas. \u00c9 melhor manter c\u00f3digo e templates separados. Portanto, criamos arquivos separados contendo o c\u00f3digo HTML para os templates. Ent\u00e3o, estes arquivos HTML pode ser referenciados para dentro dos views pelos seus nomes. Flask cont\u00e9m uma fun\u00e7\u00e3o chamada render_template() que \u00e9 usada para renderizar os templates HTML desejados. Este m\u00e9todo tem os seguintes par\u00e2metros: template_name_or_list : O nome do template ou de uma lista de templates (o m\u00e9todo vai renderizar o primeiro template da lista). context (opcional): vari\u00e1vel que devem estar dispon\u00edveis dentro do template. O output de render_template() ent\u00e3o \u00e9 retornado pela view ao inv\u00e9s de uma simples String, como est\u00e1vamos fazendo previamente. def view_name(): return render_template(template_name)","title":"Fun\u00e7\u00e3o render_template"},{"location":"Flask/#estrategias-de-estrutura-de-arquivos","text":"O framework Flask procura pelos arquivos de template HTML dentro de um diret\u00f3rio nomeado \\templates . Este diret\u00f3rio deve ser posto de forma que Flask possa encontrar.","title":"Estrat\u00e9gias de estrutura de arquivos"},{"location":"Flask/#estrutura-de-arquivos-em-modulo","text":"Se seguir uma estrutura de arquivos modular em nosso projeto, um diret\u00f3rio separado chamado \"templates\" pode ser criado no mesmo diret\u00f3rio que o m\u00f3dulo principal da aplica\u00e7\u00e3o. (ex: app.py ).","title":"Estrutura de arquivos em m\u00f3dulo"},{"location":"Flask/#estrutura-de-arquivo-em-pacotes","text":"Se a l\u00f3gica da aplica\u00e7\u00e3o est\u00e1 dividida em m\u00f3dulos separados, ent\u00e3o estes arquivos est\u00e3o presentes no mesmo pacote. Em Python, um pacote \u00e9 simplesmente um diret\u00f3rio contendo um arquivo nomeado como __init__.py . Se esta estrutura esta sendo seguida em nossa aplica\u00e7\u00e3o, ent\u00e3o iremos criar o diret\u00f3rio templates dentro do pacote da aplica\u00e7\u00e3o principal.","title":"Estrutura de arquivo em pacotes"},{"location":"Flask/#arquivos-estaticos","text":"","title":"Arquivos Est\u00e1ticos"},{"location":"Flask/#como-servimos-arquivos-estaticos","text":"Arquivos est\u00e1ticos (ou assets), s\u00e3o arquivos que o servidor manda para o cliente \"como eles s\u00e3o\", sem qualquer interven\u00e7\u00e3o. Por exemplo, qualquer arquivo css , ou JavaScript que podemos ter em nosso website s\u00e3o enviados para o cliente sem qualquer modifica\u00e7\u00e3o.","title":"Como Servimos Arquivos Est\u00e1ticos?"},{"location":"Flask/#passos-para-servir-arquivos-estaticos","text":"Os passos a seguir s\u00e3o necess\u00e1rios para hospedar um asset est\u00e1tico.","title":"Passos para servir Arquivos Est\u00e1ticos"},{"location":"Flask/#criar-um-diretorio-static","text":"As mesmas estrat\u00e9gias de estruturas de arquivos tamb\u00e9m se aplicam aqui.","title":"Criar um diret\u00f3rio \\static"},{"location":"Flask/#criar-uma-url-para-arquivos-estaticos","text":"N\u00e3o usamos views para arquivos est\u00e1ticos. Ent\u00e3o, para criar uma URL separada para eles, usamos a fun\u00e7\u00e3o url_for() .","title":"Criar uma URL para arquivos est\u00e1ticos"},{"location":"Flask/#funcao-url_for","text":"A fun\u00e7\u00e3o url_for() \u00e9 usada para criar uma URL para certo endpoint. Podemos us\u00e1-la para criar URLs para views tamb\u00e9m. Ela leva o nome do endpoint e quaisquer vari\u00e1veis associadas como argumentos. url_for('view_function_name', variable_name = 'value_of_variable') \ud83e\udd14 Porque precisamos usar url_for() se podemos escrever a URL? A fun\u00e7\u00e3o url_for() sempre retorna a URL absoluta para o endpoint. Portanto, chamamos ela em qualquer lugar do projeto e n\u00e3o teremos problemas com caminhos relativos. Se acabarmos mudando o caminho para um endpoint ou rota para uma view, n\u00e3o temos que mudar a URL escrita em todo o projeto. A URL para um arquivo est\u00e1tico pode ser criada usando um endpoint static como a seguir: url_for('static', filename = 'name_of_file')","title":"Fun\u00e7\u00e3o url_for()"},{"location":"Flask/#exemplo","text":"<!DOCTYPE html> <html> <head> <link rel=\"stylesheet\" href=\"{{url_for('static', filename='borders.css')}}\" /> </head> <body> <h1>Home Page!</h1> <p>Welcome to the homepage for \"How to Server Static Files\" Demo!</p> </body> </html> Chaves duplas fazem parte da sintaxe de Jinja","title":"Exemplo"},{"location":"Flask/#templates-dinamicos","text":"","title":"Templates Din\u00e2micos"},{"location":"Flask/#templates-jinja2","text":"Considere que estamos fazendo uma aplica\u00e7\u00e3o com m\u00faltiplos usu\u00e1rios, tal como uma rede social, cada usu\u00e1rio ter\u00e1 um perfil \u00fanico com informa\u00e7\u00f5es \u00fanicas associadas a ele. \u00c9 nosso trabalho na aplica\u00e7\u00e3o web servir um template \u00fanico contendo o conte\u00fado correspondente a usu\u00e1rio que est\u00e1 logado. Podemos observar, que do lado do servidor, um template gen\u00e9rico est\u00e1 colocado contendo uma variable rule . Quando este template \u00e9 renderizado no lado do cliente, uma valor apropriado \u00e9 colocado ao inv\u00e9s da rule . Esse novo valor \u00e9 de acordo com o contexto da aplica\u00e7\u00e3o. Este tipo de comportamento din\u00e2mico de um template \u00e9 chamado de dynamic templating . Muitas tecnologias server-side nos permitem implementar comportamento de template din\u00e2mico. Flask tem suporte embutido para uma engine para cria\u00e7\u00e3o de templates din\u00e2micos chamada Jinja .","title":"Templates Jinja2"},{"location":"Flask/#a-engine-de-template-jinja","text":"Um arquivo de template Jinja \u00e9 um arquivo de texto que n\u00e3o tem uma extens\u00e3o em particular. Usaremos extens\u00e3o .html com os arquivos de template porque eles tamb\u00e9m ir\u00e3o incluir sintaxe HTML .","title":"A Engine de Template Jinja"},{"location":"Flask/#delimitadores","text":"{% ... %} \u00e9 usado para declara\u00e7\u00f5es. {{ ... }} \u00e9 usado para vari\u00e1veis. {# ... #} \u00e9 usado para coment\u00e1rios. # ... ## \u00e9 usado para declara\u00e7\u00f5es de linha.","title":"Delimitadores"},{"location":"Flask/#variaveis","text":"Podemos inserir vari\u00e1veis dentro de templates seguindo estes dois passos: 1 . O objeto \u00e9 fornecido com um argumento nomeado para a fun\u00e7\u00e3o render_template() . return render_template(\"index.html\", my_object = Object) O valor desse objeto \u00e9 buscado dentro do template usando a sintaxe {{}} . {{ my_object }}","title":"Vari\u00e1veis"},{"location":"Flask/#fluxo-de-controle-com-jinja","text":"Jinja tamb\u00e9m fornece sintaxe para lidar com fluxo de controle de um aplica\u00e7\u00e3o dentro dos seus templates. Loops e condi\u00e7\u00f5es podem ser adicionadas aos templates utilizando a sintaxe pythonica fornecida pelo Jinja.","title":"Fluxo de controle com Jinja"},{"location":"Flask/#loops","text":"A sintaxe de for \u00e9 bem parecida com a de python. {% for elements in array %} ... {% endfor %}","title":"Loops"},{"location":"Flask/#condicionais","text":"{% if true %} {% endif %} M\u00faltiplas ramifica\u00e7\u00f5es utilizando elif e else . {% if ... %} {% elif ... %} {% else %} {% endif %}","title":"Condicionais"},{"location":"Flask/#template-inheritance","text":"","title":"Template Inheritance"},{"location":"Flask/#blocks","text":"Em Jinja, blocks s\u00e3o usados como placeholders e tamb\u00e9m como substitutos. No template pai , estes blocos s\u00e3o usados como placeholders . Enquanto que no template filho, eles s\u00e3o usados como substitutos.","title":"Blocks"},{"location":"Flask/#basehtml","text":"<!DOCTYPE html> <html lang=\"en\"> <head> <link rel=\"stylesheet\" href=\"{{url_for('static', filename='format.css')}}\" /> <title>{% block title %}<!-- Placeholder for Title -->{% endblock %} - Jinja Demo</title> {% block head %} <!-- Placeholder for Other Imports --> {% endblock %} </head> <body> <div id=\"header\"> JINJA DEMO </div> <div id=\"content\"> {% block content %} <!-- Placeholder for Page Content --> {% endblock %} </div> <div id=\"footer\"> Copyright \u00a9 2019 All Rights Reserved </div> </body> </html>","title":"base.html"},{"location":"Flask/#homehtml","text":"{% extends \"base.html\" %} <!-- Replacement for Title --> {% block title %} Home Page {% endblock %} <!-- Replacement for Content --> {% block content %} <h1>Home Page</h1> <p>Welcome to the Jinja2 Demo.</p> {% endblock %}","title":"home.html"},{"location":"Flask/#abouthtml","text":"{% extends \"base.html\" %} <!-- Replacement for Title --> {% block title %} About Page {% endblock %} <!-- Replacement for Content --> {% block content %} <h1>About Page</h1> <p>In this lesson we are learning about Template Inheritance</p> {% endblock %}","title":"about.html"},{"location":"Flask/#forms","text":"O pacote Flask n\u00e3o fornece uma forma de lidar com formul\u00e1rios. Existem duas formas que desenvolvedor lidam com isso: Via objeto request . Via extens\u00e3o Flask-WTF .","title":"Forms"},{"location":"Flask/#utilizando-request","text":"Por padr\u00e3o, o decorator route() serve apenas requisi\u00e7\u00f5es get . Portanto, devemos fornecer um par\u00e2metro extra, chamado methods para o decorator route() . @app.route(\"/login\", methods=[\"GET\", \"POST\"]) login.html {% block content %} <h1>Login</h1> <form action=\"{{url_for('login')}}\" method=\"POST\"> Email:<br> <input type=\"text\" name=\"email\" > <br> Password:<br> <input type=\"password\" name=\"password\" > <br><br> <input type=\"submit\" value=\"Login\"> </form> {% endblock %}","title":"Utilizando Request"},{"location":"Flask/#data-handling-usando-objeto-request","text":"Para acessar dados enviados pelo usu\u00e1rio usamos o objeto global request . from flask import request","title":"Data Handling usando objeto Request"},{"location":"Flask/#recebendo-o-tipo-de-method-de-request","text":"Podemos utilizar o atributo method do objeto request para determinar o m\u00e9todo de um requisi\u00e7\u00e3o entrante. @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": ... else ... return render_template(\"login.html\")","title":"Recebendo o tipo de method de request."},{"location":"Flask/#recebendo-form-data-de-request","text":"Podemos usar o atributo form de um objeto request para obter os valores que o usu\u00e1rio submeteu. a form \u00e9 uma estrutura de dados especial chamado ImmutableMultiDict . @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": email = request.form[\"email\"] password = request.form[\"password\"] ... else: ... return render_template(\"login.html\")","title":"Recebendo Form data de request"},{"location":"Flask/#exemplo-com-logica-de-validacao","text":"from flask import Flask, render_template from flask import request app = Flask(__name__) users = { \"archie.andrews@email.com\": \"football4life\", \"veronica.lodge@email.com\": \"fashiondiva\" } @app.route(\"/\") def home(): return render_template(\"home.html\") @app.route(\"/login\", methods=[\"GET\", \"POST\"]) def login(): if request.method == \"POST\": email = request.form[\"email\"] password = request.form[\"password\"] if email in users and users[email] == password: return render_template(\"login.html\", message =\"Successfully Logged In\") return render_template(\"login.html\", message =\"Incorrect Email or Password\") return render_template(\"login.html\") if __name__ == \"__main__\": app.run(debug=True, host=\"0.0.0.0\", port=3000) login.html {% block content %} <h1>Login</h1> {% if message %} {{ message }} {% endif %} <form action=\"{{url_for('login')}}\" method=\"POST\"> Email:<br> <input type=\"text\" name=\"email\" > <br> Password:<br> <input type=\"password\" name=\"password\" > <br><br> <input type=\"submit\" value=\"Login\"> </form> <hr> {% endblock %}","title":"Exemplo com L\u00f3gica de Valida\u00e7\u00e3o"},{"location":"Flask/#criando-formularios-usando-flask-wtf-e-wtforms","text":"Em nossa aplica\u00e7\u00e3o n\u00e3o t\u00ednhamos nenhuma checagem para email e password porque era um exemplo simples. Se quisermos adicionar esses checks dever\u00edamos escreve l\u00f3gica para isso no front end ou no backend (dentro da view login ). Em aplica\u00e7\u00f5es maiores esses tipos de componentes extras podem facilmente se tornar boiler-plate e dif\u00edcil de ler, para esse prop\u00f3sito algumas biblioteca tornam este processo mais f\u00e1cil. WTForms : \u00c9 um biblioteca que torna trabalhar com formul\u00e1rios f\u00e1cil. Ela lida n\u00e3o apenas com valida\u00e7\u00e3o mas tamb\u00e9m com a renderiza\u00e7\u00e3o no front-end. Adicionalmente, WTForms n\u00e3o \u00e9 limitada somente a Flask. Flask-WTF : \u00c9 uma biblioteca espec\u00edfica de Flask que integra a biblioteca WTForm com Flask . Age como um add-on de WTForms e adiciona alguns componentes extra, como seguran\u00e7a. Criando um m\u00f3dulo forms: Primeiro, separamos nosso m\u00f3dulo da aplica\u00e7\u00e3o do m\u00f3dulo dos formul\u00e1rios. Adicionaremos um novo arquivo chamado forms.py , que agir\u00e1 como um m\u00f3dulo de formul\u00e1rios. Importando FlaskForm de flask_wtf : from flask_wtf import FlaskForm # Essa classe \u00e9 uma subclasse de Form da bilioteca wtforms Criando classe LoginForm : Para cada formul\u00e1rio em nosso website, criaremos uma classe a medida em que estamos criando um formul\u00e1rio de login. Portanto, vamos nomear essa classe LoginForm . Esta classe ir\u00e1 herdar da classe FlaskForm importada previamente. class LoginForm(FlaskForm): ... Adicionando campos de formul\u00e1rio de wtforms O formul\u00e1rio de login anterior tinha 3 componentes: Um campo de input para email. Um campo de input para password. O campo do bot\u00e3o submit. Para todo campo poss\u00edvel, wtforms tem classes associadas. Para este exemplo particular, importaremos apenas os campos que precisamos: StringField para email. PasswordField para um password. SubmitField para o bot\u00e3o submit. from wtforms import StringField, PasswordField, SubmitField Agora vamos criar inst\u00e2ncias dessas classes como vari\u00e1veis membros da nossa classe e iremos passar os r\u00f3tulos desses campos como inputs para os construtores. class LoginForm(FlaskForm): email = StringField('Email') password = PasswordField('Password') submit = SubmitField('Login') Adicionar validadores de campo do wtforms : Validadores s\u00e3o regras e checks que queremos aplicar aos nossos campos dentro de um formul\u00e1rio. Por exemplo, em um campo de email queremos ter certeza de que o input \u00e9 um email v\u00e1lido. Para esse prop\u00f3sito iremos usar o validador Email . from wtforms.validators import InputRequired, Email Para aplicar estes validadores aos campos, fornecemos uma lista de validadores como par\u00e2metros a eles: class LoginForm(FlaskForm): email = StringField('Email', validators=[InputRequired(), Email()]) password = PasswordField('Password', validators=[InputRequired()]) submit = SubmitField('Login') InputRequired(): coloca o atributo required no HTML. Email() : checa se o input \u00e9 um email v\u00e1lido. Implementa\u00e7\u00e3o completa from flask_wtf import FlaskForm from wtforms import StringField, PasswordField, SubmitField from wtforms.validators import InputRequired, Email class LoginForm(FlaskForm): email = StringField('Email', validators=[InputRequired(), Email()]) password = PasswordField('Password', validators=[InputRequired()]) submit = SubmitField('Login')","title":"Criando Formul\u00e1rios usando Flask-WTF e WTForms"},{"location":"Flask/#renderizando-formularios-flask-wtf-em-templates","text":"","title":"Renderizando formul\u00e1rios Flask-WTF em templates"},{"location":"Machine%20Learning%20For%20Software%20Enginners/","text":"7 Passos do Machine Learning Coleta de Dados Processamento e Prepara\u00e7\u00e3o de dados Engenharia de Features Sele\u00e7\u00e3o de Modelos Treinamento de Modelos e Pipeline de Dados Valida\u00e7\u00e3o de Modelo Persist\u00eancia do Modelo","title":"7 Passos do Machine Learning"},{"location":"Machine%20Learning%20For%20Software%20Enginners/#7-passos-do-machine-learning","text":"Coleta de Dados Processamento e Prepara\u00e7\u00e3o de dados Engenharia de Features Sele\u00e7\u00e3o de Modelos Treinamento de Modelos e Pipeline de Dados Valida\u00e7\u00e3o de Modelo Persist\u00eancia do Modelo","title":"7 Passos do Machine Learning"}]}